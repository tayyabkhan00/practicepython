<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Northern Lights — Three.js</title>
  <style>
    html,body { height:100%; margin:0; background: #000; font-family: system-ui, -apple-system, sans-serif; }
    #container { position:fixed; inset:0; overflow:hidden; }
    .ui { position: absolute; right: 18px; top: 18px; color: #dfeffb; backdrop-filter: blur(6px) saturate(120%); background: rgba(10,18,25,0.25); border-radius: 12px; padding: 12px; box-shadow: 0 6px 30px rgba(0,0,0,0.6); }
    .ui h3 { margin:0 0 8px 0; font-size:14px; color:#eaf6ff }
    .ui label { display:block; font-size:12px; margin-top:8px; opacity:0.9 }
    input[type=range] { width:170px }
    a.credit { color:#9fd7ff; text-decoration:none; font-size:12px; display:block; margin-top:8px }
    #fallback { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; color:#fff }
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="ui">
    <h3>Northern Lights — Controls</h3>
    <label>Aurora Strength <input id="strength" type="range" min="0" max="4" step="0.01" value="1.25"></label>
    <label>Wave Speed <input id="speed" type="range" min="0" max="3" step="0.01" value="0.9"></label>
    <label>Glow (bloom) <input id="bloom" type="range" min="0" max="2" step="0.01" value="1.0"></label>
    <a class="credit" href="#">Click+Drag to orbit · Scroll to zoom</a>
  </div>
  <div id="fallback" hidden>WebGL required — please open in a modern browser.</div>

  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
  import { EffectComposer } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'https://unpkg.com/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js';

  const container = document.getElementById('container');
  if (!WEBGL.isWebGLAvailable && !THREE.WEBGL.isWebGLAvailable()) {
    document.getElementById('fallback').hidden = false;
  }

  // Renderer
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.outputEncoding = THREE.sRGBEncoding;
  container.appendChild(renderer.domElement);

  // Scene + Camera
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000010, 0.0009);
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 12, 30);

  // Controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.maxPolarAngle = Math.PI * 0.49;
  controls.minDistance = 6;
  controls.maxDistance = 60;

  // Stars
  function makeStars() {
    const g = new THREE.BufferGeometry();
    const count = 12000;
    const pos = new Float32Array(count * 3);
    for (let i=0;i<count;i++){
      const r = 60 + Math.random()*160;
      const theta = Math.random()*Math.PI*2;
      const phi = Math.acos(2*Math.random()-1);
      pos[i*3] = r*Math.sin(phi)*Math.cos(theta);
      pos[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
      pos[i*3+2] = r*Math.cos(phi);
    }
    g.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const m = new THREE.PointsMaterial({ size: 0.08, transparent:true, opacity:0.9 });
    const p = new THREE.Points(g,m);
    p.rotation.y = Math.PI/4;
    scene.add(p);
  }
  makeStars();

  // Aurora shader
  const auroraVertex = `
    varying vec2 vUv;
    varying vec3 vPos;
    void main() {
      vUv = uv;
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  // Classic noise by Inigo Quilez (IQ) - classic 3D noise
  const auroraFragment = `
    precision highp float;
    varying vec2 vUv;
    varying vec3 vPos;
    uniform float time;
    uniform float strength;
    uniform float speed;
    // iq's hash and noise
    vec3 hash3(vec3 p) {
      p = vec3(dot(p, vec3(127.1,311.7, 74.7)), dot(p, vec3(269.5,183.3,246.1)), dot(p, vec3(113.5,271.9,124.6)));
      return -1.0 + 2.0*fract(sin(p)*43758.5453123);
    }
    float noise(vec3 p){
      vec3 i = floor(p);
      vec3 f = fract(p);
      vec3 u = f*f*(3.0-2.0*f);
      float n000 = dot(hash3(i + vec3(0.0,0.0,0.0)), f - vec3(0.0));
      float n100 = dot(hash3(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0));
      float n010 = dot(hash3(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0));
      float n110 = dot(hash3(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0));
      float n001 = dot(hash3(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0));
      float n101 = dot(hash3(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0));
      float n011 = dot(hash3(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0));
      float n111 = dot(hash3(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0));
      float nx00 = mix(n000, n100, u.x);
      float nx10 = mix(n010, n110, u.x);
      float nx01 = mix(n001, n101, u.x);
      float nx11 = mix(n011, n111, u.x);
      float nxy0 = mix(nx00, nx10, u.y);
      float nxy1 = mix(nx01, nx11, u.y);
      return mix(nxy0, nxy1, u.z);
    }

    void main(){
      // position-based coordinates for broad stretching
      vec2 uv = vUv * vec2(4.0, 1.0);
      float y = vPos.y * 0.06;
      float t = time * speed * 0.15;

      // layered noise
      float n = 0.0;
      float amp = 1.0;
      float freq = 1.0;
      for (int i=0;i<5;i++){
        n += amp * noise(vec3(uv.x*freq, uv.y*1.1 + y*3.0, t + float(i)*7.0));
        amp *= 0.5;
        freq *= 2.0;
      }

      // shape mask (fade toward edges and lower part)
      float mask = smoothstep(-0.2, 1.1, n);
      float band = smoothstep(0.0, 1.0, vUv.y*3.0 + n*0.9);
      float intensity = mask * band * strength;

      // color ramp — shift across spectrum
      vec3 col = vec3(0.0);
      float hue = 0.55 + 0.3 * n + 0.05 * sin(time*0.1 + vUv.x*6.0);
      // aurora colors: teal -> green -> purple
      vec3 c1 = vec3(0.0, 0.95, 0.82);
      vec3 c2 = vec3(0.3, 1.0, 0.2);
      vec3 c3 = vec3(0.6, 0.3, 0.9);
      if (hue < 0.6) col = mix(c1, c2, (hue-0.2)/0.4);
      else col = mix(c2, c3, (hue-0.6)/0.4);

      // vertical soft glow layering
      float glow = exp(-pow((vUv.y-0.6)*6.0,2.0));
      vec3 final = col * intensity * (0.9 + 0.8*glow);

      // add subtle vertical streaking
      float streak = pow(abs(vUv.x-0.5), 0.7);
      final *= (1.0 - 0.25*streak);

      // additive blending simulated by brightening near strong values
      gl_FragColor = vec4(final, clamp(intensity*1.2, 0.0, 1.0));
    }
  `;

  // Create layered aurora planes
  const auroraGroup = new THREE.Group();
  const planeGeo = new THREE.PlaneGeometry(40, 14, 200, 50);
  const planeGeo2 = new THREE.PlaneGeometry(60, 22, 240, 60);

  const createAurora = (geo, offset, s, colShift) => {
    const mat = new THREE.ShaderMaterial({
      vertexShader: auroraVertex,
      fragmentShader: auroraFragment,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        time: { value: 0 },
        strength: { value: s },
        speed: { value: 1.0 }
      }
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.rotation.x = -Math.PI*0.15 - offset*0.02;
    mesh.position.set(0, 6 + offset*0.8, -6 - offset*1.2);
    auroraGroup.add(mesh);
    return mesh;
  };

  const a1 = createAurora(planeGeo, -1.0, 1.3, 0.0);
  const a2 = createAurora(planeGeo2, 0.4, 0.9, 0.1);
  const a3 = createAurora(planeGeo, 1.4, 0.6, -0.15);
  scene.add(auroraGroup);

  // Subtle ground silhouette
  const groundGeo = new THREE.PlaneGeometry(400, 200);
  const groundMat = new THREE.MeshBasicMaterial({ color: 0x02030a });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -8;
  ground.position.z = -40;
  scene.add(ground);

  // Soft rim lights to give depth
  const rimLight1 = new THREE.DirectionalLight(0x88f2ff, 0.35);
  rimLight1.position.set(-5, 16, 10);
  scene.add(rimLight1);
  const rimLight2 = new THREE.DirectionalLight(0xffc6ff, 0.15);
  rimLight2.position.set(5, 8, -10);
  scene.add(rimLight2);

  // Postprocessing (composer + bloom)
  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.6, 0.1);
  composer.addPass(bloom);

  // UI elements
  const strengthEl = document.getElementById('strength');
  const speedEl = document.getElementById('speed');
  const bloomEl = document.getElementById('bloom');
  strengthEl.addEventListener('input', ()=>{
    [a1.material.uniforms.strength.value, a2.material.uniforms.strength.value, a3.material.uniforms.strength.value] = [parseFloat(strengthEl.value)*1.1, parseFloat(strengthEl.value)*0.7, parseFloat(strengthEl.value)*0.5];
  });
  speedEl.addEventListener('input', ()=>{
    [a1.material.uniforms.speed.value, a2.material.uniforms.speed.value, a3.material.uniforms.speed.value] = [parseFloat(speedEl.value)*1.0, parseFloat(speedEl.value)*0.8, parseFloat(speedEl.value)*1.3];
  });
  bloomEl.addEventListener('input', ()=>{
    bloom.strength = parseFloat(bloomEl.value);
  });

  // Resize
  window.addEventListener('resize', onWindowResize);
  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  }

  // animate
  const clock = new THREE.Clock();
  function animate(){
    const t = clock.getElapsedTime();
    a1.material.uniforms.time.value = t;
    a2.material.uniforms.time.value = t*1.1 + 7.0;
    a3.material.uniforms.time.value = t*0.8 + 14.0;

    // subtle group movement
    auroraGroup.rotation.z = Math.sin(t*0.07)*0.08;
    auroraGroup.position.x = Math.sin(t*0.04)*1.8;

    controls.update();
    composer.render();
    requestAnimationFrame(animate);
  }
  // initialize UI values into materials
  strengthEl.dispatchEvent(new Event('input'));
  speedEl.dispatchEvent(new Event('input'));
  bloomEl.dispatchEvent(new Event('input'));
  animate();

  </script>

  <!-- small helper to detect WebGL: include a safe WEBGL helper if missing -->
  <script>
    // minimal WEBGL helper when not bundled
    window.WEBGL = window.WEBGL || {
      isWebGLAvailable: function(){ try{ const c=document.createElement('canvas'); return !!(window.WebGLRenderingContext && (c.getContext('webgl')||c.getContext('experimental-webgl'))); }catch(e){return false;} }
    };
  </script>
</body>
</html>
