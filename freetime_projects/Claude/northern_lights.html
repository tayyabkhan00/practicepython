<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Northern Lights</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #0a0e27 0%, #1a1f3a 50%, #000000 100%);
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            z-index: 100;
        }
        h1 {
            margin: 0;
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 2px;
        }
        p {
            margin: 5px 0;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>AURORA BOREALIS</h1>
        <p>Drag to rotate â€¢ Scroll to zoom</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, auroras = [], stars;
        let mouseX = 0, mouseY = 0;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 50);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            createStars();
            createAuroras();
            createGround();
            createMountains();

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            window.addEventListener('resize', onResize);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('wheel', onWheel);
        }

        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < 3000; i++) {
                const x = (Math.random() - 0.5) * 400;
                const y = Math.random() * 200 + 50;
                const z = (Math.random() - 0.5) * 400;
                vertices.push(x, y, z);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ 
                color: 0xffffff, 
                size: 0.5,
                transparent: true,
                opacity: 0.8
            });
            
            stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        function createAuroras() {
            const colors = [
                [0x00ff88, 0x00ffff], // Green to cyan
                [0x00ffaa, 0x00ff00], // Cyan to green
                [0xff00ff, 0x00ffff], // Magenta to cyan
                [0x00ff00, 0xaaff00]  // Green to lime
            ];

            for (let i = 0; i < 4; i++) {
                const geometry = new THREE.PlaneGeometry(100, 40, 50, 20);
                const positions = geometry.attributes.position.array;
                
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j + 2] = Math.sin(positions[j] * 0.1) * 3;
                }
                
                const colorPair = colors[i];
                const material = new THREE.MeshBasicMaterial({
                    color: colorPair[0],
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                const aurora = new THREE.Mesh(geometry, material);
                aurora.position.set(
                    (Math.random() - 0.5) * 60,
                    20 + i * 5,
                    -30 - i * 10
                );
                aurora.rotation.x = Math.PI / 6;
                aurora.userData = {
                    initialY: aurora.position.y,
                    speed: 0.0005 + Math.random() * 0.001,
                    offset: Math.random() * Math.PI * 2,
                    colorPair: colorPair
                };
                
                scene.add(aurora);
                auroras.push(aurora);
            }
        }

        function createGround() {
            const geometry = new THREE.PlaneGeometry(300, 300, 50, 50);
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] = Math.random() * 2;
            }
            
            const material = new THREE.MeshBasicMaterial({
                color: 0x0a0a1a,
                transparent: true,
                opacity: 0.8
            });
            
            const ground = new THREE.Mesh(geometry, material);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -10;
            scene.add(ground);
        }

        function createMountains() {
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.ConeGeometry(10 + Math.random() * 10, 20 + Math.random() * 15, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x0f0f1f,
                    transparent: true,
                    opacity: 0.6
                });
                
                const mountain = new THREE.Mesh(geometry, material);
                mountain.position.set(
                    (Math.random() - 0.5) * 100,
                    0,
                    -50 - Math.random() * 30
                );
                mountain.rotation.y = Math.random() * Math.PI;
                scene.add(mountain);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            auroras.forEach((aurora, index) => {
                const geometry = aurora.geometry;
                const positions = geometry.attributes.position.array;
                const userData = aurora.userData;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const y = positions[i + 1];
                    positions[i + 2] = Math.sin(x * 0.1 + time * 2 + userData.offset) * 3 + 
                                       Math.cos(y * 0.1 + time * 1.5) * 2;
                }
                
                geometry.attributes.position.needsUpdate = true;
                
                aurora.material.opacity = 0.2 + Math.sin(time * userData.speed * 1000 + userData.offset) * 0.15;
                
                const t = (Math.sin(time * 0.5 + userData.offset) + 1) / 2;
                const color1 = new THREE.Color(userData.colorPair[0]);
                const color2 = new THREE.Color(userData.colorPair[1]);
                aurora.material.color.lerpColors(color1, color2, t);
                
                aurora.position.y = userData.initialY + Math.sin(time * 0.3 + userData.offset) * 2;
            });
            
            stars.rotation.y += 0.0001;
            
            camera.position.x += (mouseX * 0.05 - camera.position.x) * 0.05;
            camera.position.y += (10 - mouseY * 0.05 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }

        function onMouseMove(e) {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        }

        function onWheel(e) {
            camera.position.z += e.deltaY * 0.05;
            camera.position.z = Math.max(20, Math.min(80, camera.position.z));
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
        animate();
    </script>
</body>
</html>